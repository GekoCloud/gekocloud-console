# babel-plugin-lego-imports

Transforms member style imports:

```javascript
import { Icon, Button as Btn } from '@QCFE/lego-ui';
```

...into default style imports:

```javascript
import Icon from '@QCFE/lego-ui/lib/components/Icon/Icon.js';
import Btn from '@QCFE/lego-ui/lib/components/Button/Button.js';
```

*Note: this plugin is not restricted to the lego-ui.  You may use it with any library.*

## That's stupid, why would you do that?

When Babel encounters a member style import such as:

```javascript
import { Icon, Button } from '@QCFE/lego-ui';
```

it will generate something similarish to:

```javascript
var legoUI = require('@QCFE/lego-ui');
var Icon = legoUI.Icon;
var Button = legoUI.Button;
```

And, the more pieces we need, the more this sucks.  This plugin will allow you
to pull in just the pieces you need, without a separate import for each item.
Additionally, it can be configured to throw when somebody accidentally writes
an import which would cause the entire module to resolve, such as:

```javascript
import Bootstrap, { Grid } from 'react-bootstrap';
// -- or --
import * as Bootstrap from 'react-bootstrap';
```

## Installation

```
npm install --save-dev @QCFE/babel-plugin-lego-imports
```

## Usage

*In .babelrc:*

```json
{
    "plugins": [
        ["@QCFE/babel-plugin-lego-imports", {
            "@QCFE/lego-ui": {
                "transform": "defaultRule",
                "preventFullImport": true
            }
        }]
    ]
}
```

The default rule is a JavaScript config file, within the lego-ui repository.

## Advanced Transformations

### Using regular expressions

Sometimes you may enforce the same convention in all folder levels on the
structure of your libraries. For achieving this dynamism, you may use regexp
to cover all tranformations.

.babelrc:

```json
{
    "plugins": [
        ["@QCFE/babel-plugin-lego-imports", {
            "my-library\/?(((\\w*)?\/?)*)": {
                "transform": "my-library/${1}/${member}",
                "preventFullImport": true
            }
        }]
    ]
}
```

For instance, the previous configuration will solve properly the next scenarios:

```javascript
import { MyModule } from 'my-library';
import { App } from 'my-library/components';
import { Header, Footer } from 'my-library/components/App';
```

becomes:

```javascript
import MyModule from 'my-library/MyModule';
import App from 'my-library/components/App';
import Header from 'my-library/components/App/Header';
import Footer from 'my-library/components/App/Footer';
```

### Using a transformation file

If you need more advanced transformation logic, you may provide a path to a .js
file which exports a function to run instead.  Keep in mind that the .js file
will be `require`d relative from this plugin's path, likely located in
`/node_modules/babel-plugin-transform-imports`.  You may provide any filename,
as long as it ends with `.js`.

.babelrc:

```json
{
    "plugins": [
        ["@QCFE/babel-plugin-lego-imports", {
            "my-library": {
                "transform": "../../path/to/transform.js",
                "preventFullImport": true
            }
        }]
    ]
}
```

/path/to/transform.js:

```js
module.exports = function(importName, matches) {
    return {
        importResultName: 'my-library/etc/' + importName.toUpperCase(),
        skipDefaultConversion: false,
    };
};
```

This is a little bit hacky, but options are a bit limited due to .babelrc being
a JSON5 file which does not support functions as a type.  In Babel 7.0, it
appears .babelrc.js files will be supported, at which point this plugin will be
updated to allow transform functions directly in the configuration file.
See: https://github.com/babel/babel/pull/4892

## Webpack

This can be used as a plugin with babel-loader.

webpack.config.js:
```js
module: {
    rules: [{
        test: /\.js$/,
        exclude: /(node_modules|bower_components)/,
        use: {
            loader: 'babel-loader',
            query: {
                plugins: [
                    [require('@QCFE/babel-plugin-lego-imports'), {
                        "my-library": {
                            "transform": function(importName) {
                                return {
                                    importResultName: 'my-library/etc/' + importName.toUpperCase(),
                                    skipDefaultConversion: false,
                                };
                            },
                            preventFullImport: true
                        }
                    }]
                ]
            }
        }
    }]
}
```

## Options

| Name | Type | Required | Default | Description |
| --- | --- | --- | --- | --- |
| `transform` | `string` | yes | `undefined` | The library name to use instead of the one specified in the import statement.  ${member} will be replaced with the import name, aka Grid/Row/Col/etc., and ${1-n} will be replaced by any matched regular expression groups. Alternatively, pass a path to a .js file which exports a function to process the transform, which is invoked with parameters: (importName, matches). (see Advanced Transformations) |
| `preventFullImport` | `boolean` | no | `false` | Whether or not to throw when an import is encountered which would cause the entire module to be imported. |
| `camelCase` | `boolean` | no | `false` | When set to true, runs ${member} through _.camelCase. |
| `kebabCase` | `boolean` | no | `false` | When set to true, runs ${member} through _.kebabCase. |
| `snakeCase` | `boolean` | no | `false` | When set to true, runs ${member} through _.snakeCase. |
| `skipDefaultConversion` | `boolean` | no | `false` | When set to true, will preserve `import { X }` syntax instead of converting to `import X`. |
