"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _react = _interopRequireWildcard(require("react"));

var _reactInputAutosize = _interopRequireDefault(require("react-input-autosize"));

var _classnames = _interopRequireDefault(require("classnames"));

var _reactDom = require("react-dom");

var _utils = require("../../utils");

var _props2 = require("./utils/props");

var _Loading = _interopRequireDefault(require("../Loading"));

var _LocaleProvider = require("../LocaleProvider");

var stringifyValue = function stringifyValue(value) {
  if (typeof value === 'string') return value;
  return value !== null && JSON.stringify(value) || '';
};

var shouldShowValue = function shouldShowValue(state, props) {
  var inputValue = state.inputValue,
      isPseudoFocused = state.isPseudoFocused,
      isFocused = state.isFocused;
  var onSelectResetsInput = props.onSelectResetsInput;
  if (!inputValue) return true;

  if (!onSelectResetsInput) {
    return !(!isFocused && isPseudoFocused || isFocused && !isPseudoFocused);
  }

  return false;
};

var shouldShowPlaceholder = function shouldShowPlaceholder(state, props, isOpen) {
  var inputValue = state.inputValue,
      isPseudoFocused = state.isPseudoFocused,
      isFocused = state.isFocused;
  var onSelectResetsInput = props.onSelectResetsInput;
  return !inputValue || !onSelectResetsInput && !isOpen && !isPseudoFocused && !isFocused;
};

var expandValue = function expandValue(value, props) {
  var valueType = (0, _typeof2.default)(value);
  if (valueType !== 'string' && valueType !== 'number') return value;
  var options = props.options,
      valueKey = props.valueKey;
  var isGroup = options.some(function (option) {
    return Object.keys(option).includes('options');
  });

  for (var i = 0; i < options.length; i += 1) {
    if (isGroup && options[i].options) {
      for (var j = 0; j < options[i].options.length; j += 1) {
        if (String(options[i].options[j][valueKey]) === String(value)) return options[i].options[j];
      }
    } else if (String(options[i][valueKey]) === String(value)) {
      return options[i];
    }
  }

  return undefined;
};

var Select =
/*#__PURE__*/
function (_Component) {
  (0, _inherits2.default)(Select, _Component);

  function Select(_props) {
    var _this;

    (0, _classCallCheck2.default)(this, Select);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Select).call(this, _props));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getOptionRef", function (ref, isFocused) {
      if (isFocused) {
        _this.focused = ref;
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getOptionLabel", function (op) {
      var labelKey = _this.props.labelKey;
      return op[labelKey];
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getFocusedOption", function () {
      return _this.currentFocusedOption;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getFocusableOption", function (selectedOption) {
      var options = _this.visibleOptions;
      if (!options.length) return null;
      var valueKey = _this.props.valueKey;
      var stateFocusedOption = _this.state.focusedOption;
      var focusedOption = stateFocusedOption || selectedOption;

      if (focusedOption && !focusedOption.disabled) {
        var focusedOptionIndex = -1;
        options.some(function (option, index) {
          var isOptionEqual = option[valueKey] === focusedOption[valueKey];

          if (isOptionEqual) {
            focusedOptionIndex = index;
          }

          return isOptionEqual;
        });

        if (focusedOptionIndex !== -1) {
          return {
            focusedOptionIndex: focusedOptionIndex,
            focusedOption: focusedOption
          };
        }
      }

      for (var i = 0; i < options.length; i += 1) {
        if (!options[i].disabled) return {
          focusedOptionIndex: i,
          focusedOption: options[i]
        };
      }

      return null;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getFocusableOptionByGroup", function (selectedOption) {
      var options = _this.visibleOptions;
      if (!options.length) return null;
      var valueKey = _this.props.valueKey;
      var stateFocusedOption = _this.state.focusedOption;
      var focusedOption = stateFocusedOption || selectedOption;

      if (focusedOption && !focusedOption.disabled) {
        var focusedOptionIndex = -1;
        options.forEach(function (groupOption, groupIndex) {
          var childOptions = groupOption.options;

          if (childOptions && childOptions.length > 0) {
            childOptions.forEach(function (option, index) {
              var isOptionEqual = option[valueKey] === focusedOption[valueKey];

              if (isOptionEqual) {
                focusedOptionIndex = "".concat(groupIndex, "-").concat(index);
              }
            });
          } else if (groupOption[valueKey] === focusedOption[valueKey]) {
            focusedOptionIndex = "".concat(groupIndex);
          }
        });

        if (focusedOptionIndex !== -1) {
          return {
            focusedOptionIndex: focusedOptionIndex,
            focusedOption: focusedOption
          };
        }
      }

      if (options[0].options) {
        for (var i = 0; i < options[0].options.length; i += 1) {
          if (!options[0].options[i].disabled) {
            return {
              focusedOptionIndex: "0-".concat(i),
              focusedOption: options[0].options[i]
            };
          }
        }
      } else {
        return {
          focusedOptionIndex: '0',
          focusedOption: options[0]
        };
      }

      return null;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getResetValue", function () {
      var _this$props = _this.props,
          resetValue = _this$props.resetValue,
          multi = _this$props.multi;

      if (resetValue !== undefined) {
        return resetValue;
      }

      if (multi) {
        return [];
      }

      return '';
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getValueArray", function (value) {
      var nextProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      var nextValue = value;
      var props = (0, _typeof2.default)(nextProps) === 'object' ? nextProps : _this.props;

      if (props.multi) {
        if (!Array.isArray(nextValue)) {
          if (nextValue === null || nextValue === undefined) return [];
          nextValue = [nextValue];
        }

        return nextValue.map(function (v) {
          return expandValue(v, props);
        }).filter(function (i) {
          return i;
        });
      }

      var expandedValue = expandValue(nextValue, props);
      return expandedValue ? [expandedValue] : [];
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "setValue", function (value) {
      var nextValue = value;
      var _this$props2 = _this.props,
          autoBlur = _this$props2.autoBlur,
          simpleValue = _this$props2.simpleValue,
          multi = _this$props2.multi,
          valueKey = _this$props2.valueKey,
          onChange = _this$props2.onChange;

      if (autoBlur) {
        _this.blurInput();
      }

      if (simpleValue && nextValue) {
        nextValue = multi ? nextValue.map(function (i) {
          return i[valueKey];
        }) : nextValue[valueKey];
      }

      if (!('value' in _this.props)) {
        _this.setState({
          value: nextValue
        });
      }

      if (onChange) {
        onChange(nextValue, value);
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "setInputValue", function (value) {
      var onInputChange = _this.props.onInputChange;
      var nextValue = value;

      if (onInputChange) {
        var nextState = onInputChange(nextValue);

        if (nextState != null && (0, _typeof2.default)(nextState) !== 'object') {
          nextValue = "".concat(nextState);
        }
      }

      _this.setState({
        inputValue: nextValue
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "focus", function () {
      if (!_this.input) return;

      _this.input.focus();
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "blurInput", function () {
      if (!_this.input) return;

      _this.input.blur();
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleTouchOutside", function (event) {
      // handle touch outside on ios to dismiss menu
      if (_this.wrapper && !_this.wrapper.contains(event.target)) {
        _this.closeMenu();
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleTouchMove", function () {
      // Set a flag that the view is being dragged
      _this.dragging = true;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleTouchStart", function () {
      // Set a flag that the view is not being dragged
      _this.dragging = false;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleTouchEnd", function (event) {
      // Check if the view is being dragged, In this case
      // we don't want to fire the click event (because the user only wants to scroll)
      if (_this.dragging) return; // Fire the mouse events

      _this.handleMouseDown(event);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleTouchEndClearValue", function (event) {
      // Check if the view is being dragged, In this case
      // we don't want to fire the click event (because the user only wants to scroll)
      if (_this.dragging) return; // Clear the value

      _this.clearValue(event);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleMouseDown", function (event) {
      var _this$props3 = _this.props,
          disabled = _this$props3.disabled,
          openOnClick = _this$props3.openOnClick,
          searchable = _this$props3.searchable;
      var _this$state = _this.state,
          isFocused = _this$state.isFocused,
          isOpen = _this$state.isOpen; // if the event was triggered by a mousedown and not the primary
      // button, or if the component is disabled, ignore it.

      if (disabled || event.type === 'mousedown' && event.button !== 0) {
        return;
      }

      if (event.target.tagName === 'INPUT') {
        if (!isFocused) {
          _this.openAfterFocus = openOnClick;

          _this.focus();
        } else if (!isOpen) {
          _this.setState({
            isOpen: true,
            isPseudoFocused: false
          });
        }

        return;
      } // prevent default event handlers


      event.preventDefault(); // for the non-searchable select, toggle the menu

      if (!searchable) {
        // This code means that if a select is searchable, onClick the options menu will not appear,
        // only on subsequent click will open it.
        var isCurrentOpen = _this.state.isOpen;

        _this.focus();

        _this.setState({
          isOpen: !isCurrentOpen
        });

        return;
      }

      if (isFocused) {
        // On iOS, we can get into a state where we think the input is focused but it isn't really,
        // since iOS ignores programmatic calls to focus() that weren't triggered by a click event.
        // Call focus() again here to be safe.
        _this.focus();

        var _assertThisInitialize = (0, _assertThisInitialized2.default)(_this),
            input = _assertThisInitialize.input;

        var toOpen = true;

        if (typeof input.getInput === 'function') {
          // Get the actual DOM input if the ref is an <AutosizeInput /> component
          input = input.getInput();
        } // clears the value so that the cursor will be at the end of input when re-renders


        input.value = '';

        if (searchable && !openOnClick) {
          toOpen = false;
        }

        if (_this.focusAfterClear) {
          toOpen = false;
          _this.focusAfterClear = false;
        } // if the input is focused, ensure the menu is open


        _this.setState({
          isOpen: toOpen,
          isPseudoFocused: false,
          focusedOption: null
        });
      } else {
        // otherwise, focus the input and open the menu
        _this.openAfterFocus = openOnClick;

        _this.focus();

        _this.setState({
          focusedOption: null
        });
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleMouseDownOnArrow", function (event) {
      var disabled = _this.props.disabled;
      var isOpen = _this.state.isOpen; // if the event was triggered by a mousedown and not the primary
      // button, or if the component is disabled, ignore it.

      if (disabled || event.type === 'mousedown' && event.button !== 0) {
        return;
      }

      event.stopPropagation();
      event.preventDefault();

      if (isOpen) {
        // close the menu
        _this.closeMenu();
      } else {
        _this.openAfterFocus = true;

        _this.focus();

        _this.setState({
          isOpen: true
        });
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleMouseDownOnMenu", function (event) {
      var disabled = _this.props.disabled; // if the event was triggered by a mousedown and not the primary
      // button, or if the component is disabled, ignore it.

      if (disabled || event.type === 'mousedown' && event.button !== 0) {
        return;
      }

      event.stopPropagation();
      event.preventDefault();
      _this.openAfterFocus = true;

      _this.focus();
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleInputFocus", function (event) {
      var _this$props4 = _this.props,
          disabled = _this$props4.disabled,
          onFocus = _this$props4.onFocus,
          openOnFocus = _this$props4.openOnFocus;
      var isOpen = _this.state.isOpen;
      if (disabled) return;
      var toOpen = isOpen || _this.openAfterFocus || openOnFocus; // if focus happens after clear values, don't open dropdown yet.

      toOpen = _this.focusAfterClear ? false : toOpen;

      if (onFocus) {
        onFocus(event);
      }

      _this.setState({
        isFocused: true,
        isOpen: !!toOpen
      });

      _this.focusAfterClear = false;
      _this.openAfterFocus = false;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleInputBlur", function (event) {
      var _this$props5 = _this.props,
          onBlur = _this$props5.onBlur,
          onBlurResetsInput = _this$props5.onBlurResetsInput; // The check for menu.contains(activeElement) is necessary to
      // prevent IE11's scrollbar from closing the menu in certain contexts.

      if (_this.menu && (_this.menu === document.activeElement || _this.menu.contains(document.activeElement))) {
        _this.focus();

        return;
      }

      if (onBlur) {
        onBlur(event);
      }

      var onBlurredState = {
        isFocused: false,
        isOpen: false,
        isPseudoFocused: false
      };

      if (onBlurResetsInput) {
        onBlurredState.inputValue = _this.handleInputValueChange('');
      }

      _this.setState(onBlurredState);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleInputChange", function (event) {
      var inputValue = _this.state.inputValue;
      var newInputValue = event.target.value;

      if (inputValue !== event.target.value) {
        newInputValue = _this.handleInputValueChange(newInputValue);
      }

      _this.setState({
        inputValue: newInputValue,
        isOpen: true,
        isPseudoFocused: false
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleInputValueChange", function (value) {
      var onInputChange = _this.props.onInputChange;
      var inputValue = _this.state.inputValue;

      if (onInputChange && value !== inputValue) {
        onInputChange(value);
      }

      return value;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "toggleTouchOutsideEvent", function (enabled) {
      if (enabled) {
        if (!document.addEventListener && document.attachEvent) {
          document.attachEvent('ontouchstart', _this.handleTouchOutside);
        } else {
          document.addEventListener('touchstart', _this.handleTouchOutside);
        }
      } else if (!document.removeEventListener && document.detachEvent) {
        document.detachEvent('ontouchstart', _this.handleTouchOutside);
      } else {
        document.removeEventListener('touchstart', _this.handleTouchOutside);
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleKeyDown", function (event) {
      var _this$props6 = _this.props,
          disabled = _this$props6.disabled,
          onInputKeyDown = _this$props6.onInputKeyDown,
          backspaceRemoves = _this$props6.backspaceRemoves,
          tabSelectsValue = _this$props6.tabSelectsValue,
          clearable = _this$props6.clearable,
          escapeClearsValue = _this$props6.escapeClearsValue,
          searchable = _this$props6.searchable,
          deleteRemoves = _this$props6.deleteRemoves;
      var _this$state2 = _this.state,
          inputValue = _this$state2.inputValue,
          isOpen = _this$state2.isOpen;
      if (disabled) return;

      if (typeof onInputKeyDown === 'function') {
        onInputKeyDown(event);

        if (event.defaultPrevented) {
          return;
        }
      }

      switch (event.keyCode) {
        case 8:
          // backspace
          if (!inputValue && backspaceRemoves) {
            event.preventDefault();

            _this.popValue();
          }

          break;

        case 9:
          // tab
          if (event.shiftKey || !isOpen || !tabSelectsValue) {
            break;
          }

          event.preventDefault();

          _this.selectFocusedOption();

          break;

        case 13:
          // enter
          event.preventDefault();
          event.stopPropagation();

          if (isOpen) {
            _this.selectFocusedOption();
          } else {
            _this.focusNextOption();
          }

          break;

        case 27:
          // escape
          event.preventDefault();

          if (isOpen) {
            _this.closeMenu();

            event.stopPropagation();
          } else if (clearable && escapeClearsValue) {
            _this.clearValue(event);

            event.stopPropagation();
          }

          break;

        case 32:
          // space
          if (searchable) {
            break;
          }

          event.preventDefault();

          if (!isOpen) {
            _this.focusNextOption();

            break;
          }

          event.stopPropagation();

          _this.selectFocusedOption();

          break;

        case 38:
          // up
          event.preventDefault();

          _this.focusPreviousOption();

          break;

        case 40:
          // down
          event.preventDefault();

          _this.focusNextOption();

          break;

        case 46:
          // delete
          if (!inputValue && deleteRemoves) {
            event.preventDefault();

            _this.popValue();
          }

          break;

        default:
          break;
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleValueClick", function (option, event) {
      var onValueClick = _this.props.onValueClick;
      if (!onValueClick) return;
      onValueClick(option, event);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleMenuScroll", function (event) {
      var onMenuScrollToBottom = _this.props.onMenuScrollToBottom;
      var inputValue = _this.state.inputValue;
      event.stopPropagation();
      if (!onMenuScrollToBottom) return;
      var target = event.target;

      if (target.scrollHeight > target.offsetHeight && target.scrollHeight - target.offsetHeight - target.scrollTop <= 0) {
        onMenuScrollToBottom(inputValue);
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "closeMenu", function () {
      var _this$props7 = _this.props,
          onCloseResetsInput = _this$props7.onCloseResetsInput,
          multi = _this$props7.multi;
      var isFocused = _this.state.isFocused;

      if (onCloseResetsInput) {
        _this.setState({
          inputValue: _this.handleInputValueChange(''),
          isOpen: false,
          isPseudoFocused: isFocused && !multi
        });
      } else {
        _this.setState({
          isOpen: false,
          isPseudoFocused: isFocused && !multi
        });
      }

      _this.hasScrolledToOption = false;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "selectValue", function (value) {
      var _this$props8 = _this.props,
          closeOnSelect = _this$props8.closeOnSelect,
          onSelectResetsInput = _this$props8.onSelectResetsInput,
          multi = _this$props8.multi,
          valueKey = _this$props8.valueKey;
      var _this$state3 = _this.state,
          inputValue = _this$state3.inputValue,
          stateValue = _this$state3.value; // NOTE: we actually add/set the value in a callback to make sure the
      // input value is empty to avoid styling issues in Chrome

      if (closeOnSelect) {
        _this.hasScrolledToOption = false;
      }

      var updatedValue = onSelectResetsInput ? '' : inputValue;

      if (multi) {
        _this.setState({
          inputValue: _this.handleInputValueChange(updatedValue),
          isOpen: !closeOnSelect
        }, function () {
          var valueArray = _this.getValueArray(stateValue);

          if (valueArray.some(function (i) {
            return i[valueKey] === value[valueKey];
          })) {
            _this.removeValue(value);
          } else {
            _this.addValue(value);
          }
        });
      } else {
        var isFocused = _this.state.isFocused;

        _this.setState({
          inputValue: _this.handleInputValueChange(updatedValue),
          isOpen: !closeOnSelect,
          isPseudoFocused: isFocused
        }, function () {
          _this.setValue(value);
        });
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "addValue", function (value) {
      var stateValue = _this.state.value;

      var valueArray = _this.getValueArray(stateValue);

      _this.setValue(valueArray.concat(value));
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "popValue", function () {
      var multi = _this.props.multi;
      var value = _this.state.value;

      var valueArray = _this.getValueArray(value);

      if (!valueArray.length) return;
      if (valueArray[valueArray.length - 1].clearableValue === false) return;

      _this.setValue(multi ? valueArray.slice(0, valueArray.length - 1) : '');
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "removeValue", function (value) {
      var valueKey = _this.props.valueKey;
      var stateValue = _this.state.value;

      var valueArray = _this.getValueArray(stateValue);

      _this.setValue(valueArray.filter(function (i) {
        return i[valueKey] !== value[valueKey];
      }));

      _this.focus();
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "clearValue", function (event) {
      var openOnClear = _this.props.openOnClear; // if the event was triggered by a mousedown and not the primary
      // button, ignore it.

      if (event && event.type === 'mousedown' && event.button !== 0) {
        return;
      }

      event.preventDefault();

      if (!openOnClear) {
        event.stopPropagation();
      }

      _this.setValue(_this.getResetValue());

      _this.setState({
        inputValue: _this.handleInputValueChange(''),
        isOpen: false
      }, _this.focus);

      _this.focusAfterClear = true;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "selectFocusedOption", function () {
      if (_this.currentFocusedOption) {
        return _this.selectValue(_this.currentFocusedOption);
      }

      return undefined;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "focusOption", function (option) {
      _this.setState({
        focusedOption: option
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "focusNextOption", function () {
      _this.focusAdjacentOption('next');
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "focusPreviousOption", function () {
      _this.focusAdjacentOption('previous');
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "focusAdjacentOption", function (dir) {
      var onSelectResetsInput = _this.props.onSelectResetsInput;
      var _this$state4 = _this.state,
          isGroup = _this$state4.isGroup,
          isOpen = _this$state4.isOpen;
      var options = [];
      var optionIndex = 0;
      var focusedIndex = -1;

      if (isGroup) {
        _this.visibleOptions.forEach(function (groupOption) {
          if (groupOption.options) {
            groupOption.options.forEach(function (option) {
              options.push({
                option: option,
                optionIndex: optionIndex
              });
              optionIndex += 1;
            });
          } else {
            options.push({
              option: groupOption,
              optionIndex: optionIndex
            });
            optionIndex += 1;
          }
        });
      } else {
        options = _this.visibleOptions.map(function (option, index) {
          return {
            option: option,
            index: index
          };
        });
      }

      options = options.filter(function (option) {
        return !option.option.disabled;
      });
      _this.scrollToFocusedOptionOnUpdate = true;

      if (!isOpen) {
        var newState = {
          focusedOption: _this.currentFocusedOption || (options.length ? options[dir === 'next' ? 0 : options.length - 1].option : null),
          isOpen: true
        };

        if (onSelectResetsInput) {
          newState.inputValue = '';
        }

        _this.setState(newState);

        return;
      }

      if (!options.length) return;
      var valueKey = _this.props.valueKey;

      for (var i = 0; i < options.length; i += 1) {
        if (_this.currentFocusedOption[valueKey] === options[i].option[valueKey]) {
          focusedIndex = i;
          break;
        }
      }

      if (dir === 'next' && focusedIndex !== -1) {
        focusedIndex = (focusedIndex + 1) % options.length;
      } else if (dir === 'previous') {
        if (focusedIndex > 0) {
          focusedIndex -= 1;
        } else {
          focusedIndex = options.length - 1;
        }
      }

      if (focusedIndex === -1) {
        focusedIndex = 0;
      }

      _this.setState({
        focusedOption: options[focusedIndex].option
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "outerReposition", function () {
      var isOpen = _this.state.isOpen;

      if (_this.menuContainer && _this.scrollParent) {
        var controlRect = _this.control ? _this.control.getBoundingClientRect() : null;

        var menuRect = _this.menuContainer.getBoundingClientRect();

        var top = controlRect.top + controlRect.height;
        var menuMargin = 8;
        _this.menuContainer.style.left = "".concat(controlRect.left, "px");

        if (_this.scrollParent !== window) {
          var scrollRect = _this.scrollParent.getBoundingClientRect();

          var scrollerBottom = scrollRect.top + scrollRect.height;
          var hasRoomBelow = top + menuRect.height + menuMargin < scrollerBottom;
          var hasRoomAbove = controlRect.top - menuRect.height - menuMargin * 2 > scrollRect.top;

          if (!hasRoomBelow && !hasRoomAbove || hasRoomBelow) {
            _this.menuContainer.style.top = "".concat(top, "px");

            if (scrollRect.top > top && isOpen) {
              _this.closeMenu();
            }
          }

          if (!hasRoomBelow && hasRoomAbove) {
            _this.menuContainer.style.top = "".concat(controlRect.top - menuRect.height - menuMargin * 2, "px");

            if (scrollerBottom < controlRect.top && isOpen) {
              _this.closeMenu();
            }
          }
        } else {
          var _hasRoomBelow = top + menuRect.height + menuMargin < window.innerHeight;

          var _hasRoomAbove = controlRect.top - menuRect.height - menuMargin * 2 > 0;

          if (!_hasRoomBelow && !_hasRoomAbove || _hasRoomBelow) {
            _this.menuContainer.style.top = "".concat(top, "px");
          }

          if (!_hasRoomBelow && _hasRoomAbove) {
            _this.menuContainer.style.top = "".concat(controlRect.top - menuRect.height - menuMargin * 2, "px");
          }
        }
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "renderValue", function (valueArray, isOpen) {
      var _this$props9 = _this.props,
          placeholder = _this$props9.placeholder,
          valueRenderer = _this$props9.valueRenderer,
          ValueComponent = _this$props9.valueComponent,
          isLoading = _this$props9.isLoading,
          onValueClick = _this$props9.onValueClick,
          multi = _this$props9.multi,
          disabled = _this$props9.disabled,
          valueKey = _this$props9.valueKey;

      var placeholderText = placeholder || _LocaleProvider.locale.get('PLEASE_SELECT');

      var renderLabel = valueRenderer || _this.getOptionLabel;

      if (isLoading && !isOpen) {
        return _react.default.createElement("div", {
          className: "select-placeholder"
        }, _react.default.createElement(_Loading.default, {
          size: 20
        }));
      }

      if (!valueArray.length) {
        var showPlaceholder = shouldShowPlaceholder(_this.state, _this.props, isOpen);
        return showPlaceholder ? _react.default.createElement("div", {
          className: "select-placeholder"
        }, placeholderText) : null;
      }

      var onClick = onValueClick ? _this.handleValueClick : null;

      if (multi) {
        return valueArray.map(function (value, i) {
          return _react.default.createElement(ValueComponent, {
            disabled: disabled || value.clearableValue === false
            /* eslint-disable react/no-array-index-key */
            ,
            key: "value-".concat(i, "-").concat(value[valueKey]),
            onClick: onClick,
            onRemove: _this.removeValue,
            placeholder: placeholderText,
            value: value,
            isMulti: true
          }, renderLabel(value, i), _react.default.createElement("span", {
            className: "select-aria-only"
          }, "\xA0"));
        });
      }

      if (shouldShowValue(_this.state, _this.props)) {
        if (isOpen) onClick = null;
        return _react.default.createElement(ValueComponent, {
          disabled: disabled,
          onClick: onClick,
          placeholder: placeholderText,
          value: valueArray[0],
          isMulti: false
        }, renderLabel(valueArray[0]));
      }

      return null;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "renderInput", function () {
      var _this$props10 = _this.props,
          propsInputProps = _this$props10.inputProps,
          onSelectResetsInput = _this$props10.onSelectResetsInput,
          tabIndex = _this$props10.tabIndex,
          inputRenderer = _this$props10.inputRenderer,
          disabled = _this$props10.disabled,
          searchable = _this$props10.searchable,
          id = _this$props10.id;
      var _this$state5 = _this.state,
          inputValue = _this$state5.inputValue,
          isFocused = _this$state5.isFocused;
      var className = (0, _classnames.default)('select-input', propsInputProps.className);
      var value = inputValue;

      if (value && !onSelectResetsInput && !isFocused) {
        // it hides input value when it is not focused and was not reset on select
        value = '';
      }

      var inputProps = (0, _objectSpread2.default)({}, propsInputProps, {
        className: className,
        onBlur: _this.handleInputBlur,
        onChange: _this.handleInputChange,
        onFocus: _this.handleInputFocus,
        ref: function ref(_ref) {
          _this.input = _ref;
        },
        autoComplete: 'off',
        role: 'combobox',
        tabIndex: tabIndex,
        value: value
      });

      if (inputRenderer) {
        return inputRenderer(inputProps);
      }

      if (disabled || !searchable) {
        var divProps = (0, _extends2.default)({}, propsInputProps);
        return _react.default.createElement("div", (0, _extends2.default)({}, divProps, {
          className: className,
          onBlur: _this.handleInputBlur,
          onFocus: _this.handleInputFocus,
          ref: function ref(_ref2) {
            _this.input = _ref2;
          },
          style: {
            border: 0,
            width: 1,
            display: 'inline-block'
          },
          tabIndex: tabIndex || 0
        }));
      }

      return _react.default.createElement(_reactInputAutosize.default, (0, _extends2.default)({
        id: id
      }, inputProps, {
        minWidth: "5"
      }));
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "renderIcon", function () {
      var prefixIcon = _this.props.prefixIcon;
      return _react.default.createElement("span", {
        className: "select-icon-zone"
      }, _react.default.createElement("span", {
        className: "select-prefix-icon"
      }, prefixIcon));
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "renderClear", function () {
      var value = _this.state.value;

      var valueArray = _this.getValueArray(value);

      var _this$props11 = _this.props,
          _this$props11$clearAl = _this$props11.clearAllText,
          clearAllText = _this$props11$clearAl === void 0 ? _LocaleProvider.locale.get('CLEAR_ALL') : _this$props11$clearAl,
          clearable = _this$props11.clearable,
          disabled = _this$props11.disabled,
          isLoading = _this$props11.isLoading,
          multi = _this$props11.multi,
          _this$props11$clearVa = _this$props11.clearValueText,
          clearValueText = _this$props11$clearVa === void 0 ? _LocaleProvider.locale.get('CLEAR_VALUE') : _this$props11$clearVa,
          clearRenderer = _this$props11.clearRenderer;

      if (!clearable || !valueArray.length || disabled || isLoading) {
        return null;
      }

      var label = multi ? clearAllText : clearValueText;
      var clear = clearRenderer();
      return _react.default.createElement("span", {
        className: "select-clear-zone",
        onMouseDown: _this.clearValue,
        onTouchEnd: _this.handleTouchEndClearValue,
        onTouchMove: _this.handleTouchMove,
        onTouchStart: _this.handleTouchStart,
        title: label
      }, clear);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "renderArrow", function () {
      var arrowRenderer = _this.props.arrowRenderer;
      if (!arrowRenderer) return null;
      var onMouseDown = _this.handleMouseDownOnArrow;
      var disabled = _this.props.disabled;
      var isOpen = _this.state.isOpen;
      var arrow = arrowRenderer({
        onMouseDown: onMouseDown,
        isOpen: isOpen,
        disabled: disabled
      });
      if (!arrow) return null;
      return _react.default.createElement("span", {
        className: "select-arrow-zone",
        onMouseDown: onMouseDown
      }, arrow);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "renderMenu", function (options, valueArray, focusedOption) {
      var _this$props12 = _this.props,
          isLoading = _this$props12.isLoading,
          isLoadingAtBottom = _this$props12.isLoadingAtBottom,
          menuRenderer = _this$props12.menuRenderer,
          labelKey = _this$props12.labelKey,
          optionClassName = _this$props12.optionClassName,
          optionComponent = _this$props12.optionComponent,
          optionRenderer = _this$props12.optionRenderer,
          valueKey = _this$props12.valueKey,
          multi = _this$props12.multi,
          _this$props12$noResul = _this$props12.noResultsText,
          noResultsText = _this$props12$noResul === void 0 ? _LocaleProvider.locale.get('NO_RESULTS_FOUND') : _this$props12$noResul;
      var inputValue = _this.state.inputValue;

      if (isLoading && !isLoadingAtBottom) {
        return _react.default.createElement("div", {
          className: "select-noresults"
        }, _react.default.createElement(_Loading.default, {
          size: 20
        }));
      }

      if (options && options.length && options.filter(function (o) {
        return !o.hidden;
      }).length) {
        return menuRenderer({
          focusedOption: focusedOption,
          focusOption: _this.focusOption,
          inputValue: inputValue,
          labelKey: labelKey,
          onFocus: _this.focusOption,
          getOptionRef: _this.getOptionRef,
          onSelect: _this.selectValue,
          optionClassName: optionClassName,
          optionComponent: optionComponent,
          optionRenderer: optionRenderer || _this.getOptionLabel,
          options: options,
          removeValue: _this.removeValue,
          selectValue: _this.selectValue,
          valueArray: valueArray,
          valueKey: valueKey,
          isMulti: multi
        });
      }

      if (noResultsText) {
        return _react.default.createElement("div", {
          className: "select-noresults"
        }, noResultsText);
      }

      return null;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "renderHiddenField", function (valueArray) {
      var _this$props13 = _this.props,
          name = _this$props13.name,
          valueKey = _this$props13.valueKey,
          disabled = _this$props13.disabled;
      if (!name) return null;
      return valueArray.map(function (item, index) {
        return _react.default.createElement("input", {
          disabled: disabled,
          key: "hidden.".concat(index),
          name: name,
          type: "hidden",
          value: stringifyValue(item[valueKey])
        });
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "renderOuter", function (options, valueArray, focusedOption) {
      var isGroup = _this.state.isGroup;
      var dimensions = _this.control ? _this.control.getBoundingClientRect() : null;

      var menu = _this.renderMenu(options, valueArray, focusedOption);

      if (!menu || !dimensions) return null;
      var outerTop = dimensions.top + dimensions.height;
      var outerLeft = dimensions.left;
      var _this$props14 = _this.props,
          menuContainerStyle = _this$props14.menuContainerStyle,
          menuStyle = _this$props14.menuStyle,
          isLoading = _this$props14.isLoading,
          isLoadingAtBottom = _this$props14.isLoadingAtBottom,
          _this$props14$bottomT = _this$props14.bottomText,
          bottomText = _this$props14$bottomT === void 0 ? _LocaleProvider.locale.get('REACH_BOTTOM') : _this$props14$bottomT,
          bottomTextVisible = _this$props14.bottomTextVisible;
      return _react.default.createElement("div", {
        ref: function ref(_ref4) {
          _this.menuContainer = _ref4;
        },
        className: (0, _classnames.default)('select-menu-outer', {
          'is-group-menu': isGroup
        }),
        style: (0, _objectSpread2.default)({}, menuContainerStyle, {
          position: 'fixed',
          width: dimensions.width,
          top: outerTop,
          left: outerLeft,
          maxHeight: 270,
          overflow: 'hidden'
        })
      }, _react.default.createElement("div", {
        className: "select-menu",
        onMouseDown: _this.handleMouseDownOnMenu,
        onScroll: _this.handleMenuScroll,
        ref: function ref(_ref3) {
          _this.menu = _ref3;
        },
        role: "listbox",
        style: (0, _objectSpread2.default)({}, menuStyle, {
          maxHeight: 270
        }),
        tabIndex: -1
      }, menu, options.length > 0 && isLoading && isLoadingAtBottom ? _react.default.createElement("div", {
        className: "bottom-wrapper"
      }, _react.default.createElement(_Loading.default, {
        size: 20
      })) : null, options.length > 0 && !isLoading && bottomTextVisible ? _react.default.createElement("div", {
        className: "bottom-wrapper"
      }, bottomText) : null));
    });
    _this.state = {
      value: _props.value || _props.defaultValue,
      inputValue: '',
      isFocused: false,
      isOpen: false,
      isGroup: false,
      isPseudoFocused: false
    };
    return _this;
  }

  (0, _createClass2.default)(Select, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props15 = this.props,
          autoFocus = _this$props15.autoFocus,
          options = _this$props15.options;

      if (autoFocus) {
        this.focus();
      }

      if (options && options.length) {
        var isGroup = options.some(function (option) {
          return Object.keys(option).includes('options');
        });
        this.setState({
          isGroup: isGroup
        });
      }

      this.scrollParent = (0, _utils.getScrollParent)(this.wrapper);

      if (this.scrollParent) {
        this.scrollParent.addEventListener('scroll', this.outerReposition);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      var _this$props16 = this.props,
          scrollMenuIntoView = _this$props16.scrollMenuIntoView,
          disabled = _this$props16.disabled,
          onOpen = _this$props16.onOpen,
          onClose = _this$props16.onClose,
          multi = _this$props16.multi;
      var isOpen = this.state.isOpen; // focus to the selected option

      if (this.menu && this.focused && isOpen && !this.hasScrolledToOption) {
        var focusedOptionNode = (0, _reactDom.findDOMNode)(this.focused);
        var menuNode = (0, _reactDom.findDOMNode)(this.menu);
        var scrollTop = menuNode.scrollTop;
        var scrollBottom = scrollTop + menuNode.offsetHeight;
        var optionTop = focusedOptionNode.offsetTop;
        var optionBottom = optionTop + focusedOptionNode.offsetHeight;

        if (scrollTop > optionTop || scrollBottom < optionBottom) {
          menuNode.scrollTop = focusedOptionNode.offsetTop;
        }

        this.hasScrolledToOption = true;
      } else if (!isOpen) {
        this.hasScrolledToOption = false;
      }

      if (this.scrollToFocusedOptionOnUpdate && this.focused && this.menu) {
        this.scrollToFocusedOptionOnUpdate = false;
        var focusedDOM = (0, _reactDom.findDOMNode)(this.focused);
        var menuDOM = (0, _reactDom.findDOMNode)(this.menu);
        var focusedRect = focusedDOM.getBoundingClientRect();
        var menuRect = menuDOM.getBoundingClientRect();

        if (focusedRect.bottom > menuRect.bottom) {
          menuDOM.scrollTop = focusedDOM.offsetTop + focusedDOM.clientHeight - menuDOM.offsetHeight;
        } else if (focusedRect.top < menuRect.top) {
          menuDOM.scrollTop = focusedDOM.offsetTop;
        }
      }

      if (scrollMenuIntoView && this.menuContainer) {
        this.outerReposition();
      }

      if (prevProps.disabled !== disabled) {
        this.setState({
          isFocused: false
        }); // eslint-disable-line react/no-did-update-set-state

        this.closeMenu();
      }

      if (prevState.isOpen !== isOpen) {
        this.toggleTouchOutsideEvent(isOpen);
        var handler = isOpen ? onOpen : onClose;
        if (handler) handler();
      }

      if (multi) {
        this.outerReposition();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.toggleTouchOutsideEvent(false);

      if (this.scrollParent) {
        this.scrollParent.removeEventListener('scroll', this.outerReposition);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props17 = this.props,
          options = _this$props17.options,
          multi = _this$props17.multi,
          propsClassName = _this$props17.className,
          prefixIcon = _this$props17.prefixIcon,
          clearable = _this$props17.clearable,
          disabled = _this$props17.disabled,
          searchable = _this$props17.searchable,
          isLoading = _this$props17.isLoading,
          size = _this$props17.size,
          wrapperStyle = _this$props17.wrapperStyle,
          style = _this$props17.style;
      var _this$state6 = this.state,
          value = _this$state6.value,
          inputValue = _this$state6.inputValue,
          isGroup = _this$state6.isGroup,
          isFocused = _this$state6.isFocused,
          isPseudoFocused = _this$state6.isPseudoFocused;
      var valueArray = this.getValueArray(value);
      this.visibleOptions = options;
      var isOpen = this.state.isOpen;

      if (multi && !options.length && valueArray.length && !inputValue) {
        isOpen = false;
      }

      var focusedOption;
      var focusedOptionInfo = isGroup ? this.getFocusableOptionByGroup(valueArray[0]) : this.getFocusableOption(valueArray[0]);
      var focusedOptionIndex = focusedOptionInfo ? focusedOptionInfo.focusedOptionIndex : null;

      if (focusedOptionIndex !== null) {
        this.currentFocusedOption = focusedOptionInfo.focusedOption;
        focusedOption = this.currentFocusedOption;
      } else {
        this.currentFocusedOption = null;
        focusedOption = null;
      }

      var className = (0, _classnames.default)('select', propsClassName, (0, _defineProperty2.default)({
        'has-value': valueArray.length,
        'has-prefix-icon': prefixIcon,
        'is-clearable': clearable,
        'is-disabled': disabled,
        'is-focused': isFocused && searchable,
        'is-loading': isLoading,
        'is-open': isOpen,
        'is-pseudo-focused': isPseudoFocused,
        'is-searchable': searchable,
        'select--multi': multi,
        'select--single': !multi
      }, "is-".concat(size), size !== 'default'));
      return _react.default.createElement("div", {
        ref: function ref(_ref6) {
          _this2.wrapper = _ref6;
        },
        className: className,
        style: wrapperStyle
      }, this.renderHiddenField(valueArray), _react.default.createElement("div", {
        ref: function ref(_ref5) {
          _this2.control = _ref5;
        },
        className: "select-control",
        onKeyDown: this.handleKeyDown,
        onMouseDown: this.handleMouseDown,
        onTouchEnd: this.handleTouchEnd,
        onTouchMove: this.handleTouchMove,
        onTouchStart: this.handleTouchStart,
        style: style
      }, prefixIcon ? this.renderIcon() : null, _react.default.createElement("span", {
        className: "select-multi-value-wrapper"
      }, this.renderValue(valueArray, isOpen), this.renderInput()), clearable ? this.renderClear() : null, this.renderArrow()), isOpen ? this.renderOuter(options, valueArray, focusedOption) : null);
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      var value = prevState.value;
      var nextState = {};

      if (nextProps.options && nextProps.options.length) {
        var isGroup = nextProps.options.some(function (option) {
          return Object.keys(option).includes('options');
        });
        nextState.isGroup = isGroup;
      }

      if ('value' in nextProps && !(0, _isEqual2.default)(nextProps.value, value)) {
        nextState.value = nextProps.value;
      }

      return nextState;
    }
  }]);
  return Select;
}(_react.Component);

(0, _defineProperty2.default)(Select, "propTypes", _props2.propTypes);
(0, _defineProperty2.default)(Select, "defaultProps", _props2.defaultProps);
var _default = Select;
exports.default = _default;