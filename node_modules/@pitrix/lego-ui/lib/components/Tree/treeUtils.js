"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDataAndAria = exports.conductExpandParent = exports.conductCheck = exports.parseCheckedKeys = exports.convertTreeToEntities = exports.calcSelectedKeys = exports.calcDropPosition = exports.getDragNodesKeys = exports.mapChildren = exports.traverseTreeNodes = exports.isCheckDisabled = exports.getNodeChildren = exports.isTreeNode = exports.getPosition = exports.posToArr = exports.arrAdd = exports.arrDel = exports.warnOnlyTreeNode = exports.toArray = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _react = _interopRequireWildcard(require("react"));

var _warning = _interopRequireDefault(require("../../utils/warning"));

var DRAG_SIDE_RANGE = 0.25;
var DRAG_MIN_GAP = 2;
var onlyTreeNodeWarned = false;

var toArray = function toArray(children) {
  var ret = [];

  _react.default.Children.forEach(children, function (c) {
    ret.push(c);
  });

  return ret;
};

exports.toArray = toArray;

var warnOnlyTreeNode = function warnOnlyTreeNode() {
  if (onlyTreeNodeWarned) return;
  onlyTreeNodeWarned = true;
  (0, _warning.default)(false, 'Tree only accept TreeNode as children.');
};

exports.warnOnlyTreeNode = warnOnlyTreeNode;

var arrDel = function arrDel(list, value) {
  var clone = list.slice();
  var index = clone.indexOf(value);

  if (index >= 0) {
    clone.splice(index, 1);
  }

  return clone;
};

exports.arrDel = arrDel;

var arrAdd = function arrAdd(list, value) {
  var clone = list.slice();

  if (clone.indexOf(value) === -1) {
    clone.push(value);
  }

  return clone;
};

exports.arrAdd = arrAdd;

var posToArr = function posToArr(pos) {
  return pos.split('-');
};

exports.posToArr = posToArr;

var getPosition = function getPosition(level, index) {
  return "".concat(level, "-").concat(index);
};

exports.getPosition = getPosition;

var isTreeNode = function isTreeNode(node) {
  return node && node.type && node.type.isTreeNode;
};

exports.isTreeNode = isTreeNode;

var getNodeChildren = function getNodeChildren(children) {
  return toArray(children).filter(isTreeNode);
};

exports.getNodeChildren = getNodeChildren;

var isCheckDisabled = function isCheckDisabled(node) {
  var _ref = node.props || {},
      disabled = _ref.disabled,
      disableCheckbox = _ref.disableCheckbox;

  return !!(disabled || disableCheckbox);
};

exports.isCheckDisabled = isCheckDisabled;

var traverseTreeNodes = function traverseTreeNodes(treeNodes, callback) {
  function processNode(node, index, parent) {
    var children = node ? node.props.children : treeNodes;
    var pos = node ? getPosition(parent.pos, index) : 0;
    var childList = getNodeChildren(children);

    if (node) {
      var data = {
        node: node,
        index: index,
        pos: pos,
        key: node.key || pos,
        parentPos: parent.node ? parent.pos : null
      };
      callback(data);
    }

    _react.Children.forEach(childList, function (subNode, subIndex) {
      processNode(subNode, subIndex, {
        node: node,
        pos: pos
      });
    });
  }

  processNode(null);
};

exports.traverseTreeNodes = traverseTreeNodes;

var mapChildren = function mapChildren(children, func) {
  var list = toArray(children).map(func);

  if (list.length === 1) {
    return list[0];
  }

  return list;
};

exports.mapChildren = mapChildren;

var getDragNodesKeys = function getDragNodesKeys(treeNodes, node) {
  var _node$props = node.props,
      eventKey = _node$props.eventKey,
      pos = _node$props.pos;
  var dragNodesKeys = [];
  traverseTreeNodes(treeNodes, function (_ref2) {
    var key = _ref2.key;
    dragNodesKeys.push(key);
  });
  dragNodesKeys.push(eventKey || pos);
  return dragNodesKeys;
};

exports.getDragNodesKeys = getDragNodesKeys;

var calcDropPosition = function calcDropPosition(event, treeNode) {
  var clientY = event.clientY;

  var _treeNode$selectHandl = treeNode.selectHandle.getBoundingClientRect(),
      top = _treeNode$selectHandl.top,
      bottom = _treeNode$selectHandl.bottom,
      height = _treeNode$selectHandl.height;

  var des = Math.max(height * DRAG_SIDE_RANGE, DRAG_MIN_GAP);

  if (clientY <= top + des) {
    return -1;
  }

  if (clientY >= bottom - des) {
    return 1;
  }

  return 0;
};

exports.calcDropPosition = calcDropPosition;

var calcSelectedKeys = function calcSelectedKeys(selectedKeys, props) {
  if (!selectedKeys) return undefined;
  var multiple = props.multiple;

  if (multiple) {
    return selectedKeys.slice();
  }

  if (selectedKeys.length) {
    return [selectedKeys[0]];
  }

  return selectedKeys;
};

exports.calcSelectedKeys = calcSelectedKeys;

function keyListToString(keyList) {
  if (!keyList) return keyList;
  return keyList.map(function (key) {
    return String(key);
  });
}

var convertTreeToEntities = function convertTreeToEntities(treeNodes) {
  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      initWrapper = _ref3.initWrapper,
      processEntity = _ref3.processEntity,
      onProcessFinished = _ref3.onProcessFinished;

  var posEntities = {};
  var keyEntities = {};
  var wrapper = {
    posEntities: posEntities,
    keyEntities: keyEntities
  };

  if (initWrapper) {
    wrapper = initWrapper(wrapper) || wrapper;
  }

  traverseTreeNodes(treeNodes, function (item) {
    var node = item.node,
        index = item.index,
        pos = item.pos,
        key = item.key,
        parentPos = item.parentPos;
    var entity = {
      node: node,
      index: index,
      key: key,
      pos: pos
    };
    posEntities[pos] = entity;
    keyEntities[key] = entity;
    entity.parent = posEntities[parentPos];

    if (entity.parent) {
      entity.parent.children = entity.parent.children || [];
      entity.parent.children.push(entity);
    }

    if (processEntity) {
      processEntity(entity, wrapper);
    }
  });

  if (onProcessFinished) {
    onProcessFinished(wrapper);
  }

  return wrapper;
};

exports.convertTreeToEntities = convertTreeToEntities;

var parseCheckedKeys = function parseCheckedKeys(keys) {
  if (!keys) {
    return null;
  }

  var keyProps;

  if (Array.isArray(keys)) {
    keyProps = {
      checkedKeys: keys,
      halfCheckedKeys: undefined
    };
  } else if ((0, _typeof2.default)(keys) === 'object') {
    keyProps = {
      checkedKeys: keys.checked || undefined,
      halfCheckedKeys: keys.halfChecked || undefined
    };
  } else {
    (0, _warning.default)(false, '`checkedKeys` is not an array or an object');
    return null;
  }

  keyProps.checkedKeys = keyListToString(keyProps.checkedKeys);
  keyProps.halfCheckedKeys = keyListToString(keyProps.halfCheckedKeys);
  return keyProps;
};

exports.parseCheckedKeys = parseCheckedKeys;

var conductCheck = function conductCheck(keyList, isCheck, keyEntities) {
  var checkStatus = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var checkedKeys = {};
  var halfCheckedKeys = {};
  (checkStatus.checkedKeys || []).forEach(function (key) {
    checkedKeys[key] = true;
  });
  (checkStatus.halfCheckedKeys || []).forEach(function (key) {
    halfCheckedKeys[key] = true;
  });

  var conductUp = function conductUp(key) {
    if (checkedKeys[key] === isCheck) return;
    var entity = keyEntities[key];
    if (!entity) return;
    var children = entity.children,
        parent = entity.parent,
        node = entity.node;
    if (isCheckDisabled(node)) return;
    var everyChildChecked = true;
    var someChildChecked = false;
    (children || []).filter(function (child) {
      return !isCheckDisabled(child.node);
    }).forEach(function (_ref4) {
      var childKey = _ref4.key;
      var childChecked = checkedKeys[childKey];
      var childHalfChecked = halfCheckedKeys[childKey];
      if (childChecked || childHalfChecked) someChildChecked = true;
      if (!childChecked) everyChildChecked = false;
    });

    if (isCheck) {
      checkedKeys[key] = everyChildChecked;
    } else {
      checkedKeys[key] = false;
    }

    halfCheckedKeys[key] = someChildChecked;

    if (parent) {
      conductUp(parent.key);
    }
  };

  var conductDown = function conductDown(key) {
    if (checkedKeys[key] === isCheck) return;
    var entity = keyEntities[key];
    if (!entity) return;
    var children = entity.children,
        node = entity.node;
    if (isCheckDisabled(node)) return;
    checkedKeys[key] = isCheck;
    (children || []).forEach(function (child) {
      conductDown(child.key);
    });
  };

  var conduct = function conduct(key) {
    var entity = keyEntities[key];

    if (!entity) {
      (0, _warning.default)(false, "'".concat(key, "' does not exist in the tree."));
      return;
    }

    var children = entity.children,
        parent = entity.parent,
        node = entity.node;
    checkedKeys[key] = isCheck;
    if (isCheckDisabled(node)) return;
    (children || []).filter(function (child) {
      return !isCheckDisabled(child.node);
    }).forEach(function (child) {
      conductDown(child.key);
    });

    if (parent) {
      conductUp(parent.key);
    }
  };

  (keyList || []).forEach(function (key) {
    conduct(key);
  });
  var checkedKeyList = [];
  var halfCheckedKeyList = [];
  Object.keys(checkedKeys).forEach(function (key) {
    if (checkedKeys[key]) {
      checkedKeyList.push(key);
    }
  });
  Object.keys(halfCheckedKeys).forEach(function (key) {
    if (!checkedKeys[key] && halfCheckedKeys[key]) {
      halfCheckedKeyList.push(key);
    }
  });
  return {
    checkedKeys: checkedKeyList,
    halfCheckedKeys: halfCheckedKeyList
  };
};

exports.conductCheck = conductCheck;

var conductExpandParent = function conductExpandParent(keyList, keyEntities) {
  var expandedKeys = {};

  function conductUp(key) {
    if (expandedKeys[key]) return;
    var entity = keyEntities[key];
    if (!entity) return;
    expandedKeys[key] = true;
    var parent = entity.parent,
        node = entity.node;
    if (isCheckDisabled(node)) return;

    if (parent) {
      conductUp(parent.key);
    }
  }

  (keyList || []).forEach(function (key) {
    conductUp(key);
  });
  return Object.keys(expandedKeys);
};

exports.conductExpandParent = conductExpandParent;

var getDataAndAria = function getDataAndAria(props) {
  return Object.keys(props).reduce(function (prev, key) {
    var newProps = prev;

    if (key.substr(0, 5) === 'data-' || key.substr(0, 5) === 'aria-') {
      newProps[key] = props[key];
    }

    return newProps;
  }, {});
};

exports.getDataAndAria = getDataAndAria;